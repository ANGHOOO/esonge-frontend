# Week 1-2: Spring Boot 프로젝트 초기 설정 및 인프라 구축

**기간**: Week 1-2
**목표**: Spring Boot 백엔드 개발 환경 구축, JPA Entity 설계, API 기반 구축
**기술 스택**: Java 17, Spring Boot 3.x, Spring Data JPA, PostgreSQL 15+, Redis 7+, AWS

---

## 📋 Issue Tickets

### [BE-001] Spring Boot 프로젝트 초기 설정

**Priority**: 🔴 Critical
**Estimated Time**: 4 hours

#### Description

Spring Boot 프로젝트의 기본 구조를 설정하고 필요한 의존성을 구성합니다. Gradle 기반 빌드 시스템을 사용하며, 멀티 모듈 구조로 확장 가능하도록 설계합니다.

#### Functional Requirements

**1. 프로젝트 구조 설계**

- Spring Initializr를 사용하여 프로젝트 생성 (또는 수동 생성)
- Gradle 빌드 시스템 사용 (build.gradle.kts 권장)
- Java 17 기준으로 설정
- Spring Boot 3.x 최신 안정 버전 사용
- 표준 레이어드 아키텍처 적용: Controller - Service - Repository - Entity

**프로젝트 디렉토리 구조:**

```
src/main/java/com/esonge/
├── config/           # Spring 설정 클래스 (@Configuration)
├── controller/       # REST API 컨트롤러 (@RestController)
├── service/          # 비즈니스 로직 (@Service)
├── repository/       # JPA Repository 인터페이스
├── entity/           # JPA Entity 클래스 (@Entity)
├── dto/              # Request/Response DTO 클래스
├── exception/        # 커스텀 예외 클래스
├── security/         # Spring Security 관련 클래스
├── util/             # 유틸리티 클래스
└── EsongeApplication.java  # Spring Boot 메인 클래스

src/main/resources/
├── application.yml              # 기본 설정
├── application-dev.yml          # 개발 환경 설정
├── application-staging.yml      # 스테이징 환경 설정
├── application-prod.yml         # 프로덕션 환경 설정
└── logback-spring.xml           # 로깅 설정
```

**2. Gradle 의존성 구성**
다음 Spring Boot Starters 및 라이브러리를 추가해야 합니다:

- spring-boot-starter-web (RESTful API)
- spring-boot-starter-data-jpa (JPA/Hibernate)
- spring-boot-starter-validation (Bean Validation)
- spring-boot-starter-data-redis (Redis)
- spring-boot-starter-security (Spring Security, 이번 주는 기본 설정만)
- postgresql (PostgreSQL JDBC 드라이버)
- lombok (보일러플레이트 코드 감소)
- springdoc-openapi-starter-webmvc-ui (Swagger/OpenAPI 문서)
- jjwt (JWT 토큰 처리, Week 3-4에서 본격 사용)

**3. 환경 변수 및 설정 파일**
application.yml에 다음 설정이 필요합니다:

- 서버 포트 (기본 8080)
- 데이터베이스 연결 정보 (spring.datasource.\*)
- JPA 설정 (ddl-auto, show-sql, hibernate 설정)
- Redis 연결 정보
- 로깅 레벨 설정
- CORS 설정 (프론트엔드 도메인 허용)
- 프로필별 설정 분리 (dev, staging, prod)

환경 변수로 관리해야 할 민감 정보:

- DB_HOST, DB_PORT, DB_NAME, DB_USERNAME, DB_PASSWORD
- REDIS_HOST, REDIS_PORT, REDIS_PASSWORD
- JWT_SECRET (Week 3-4에서 사용)
- AWS_ACCESS_KEY_ID, AWS_SECRET_ACCESS_KEY (Week 5 이후 S3 사용)

**4. 기본 헬스 체크 엔드포인트**
Spring Boot Actuator를 추가하여 헬스 체크를 제공합니다:

- `/actuator/health` - 애플리케이션 상태 확인
- `/actuator/info` - 애플리케이션 정보

또는 간단한 커스텀 헬스 체크 컨트롤러를 작성할 수도 있습니다:

- `GET /api/health` - JSON 응답으로 서버 상태 및 타임스탬프 반환

**5. Code Quality 도구 설정**

- Checkstyle 또는 SpotBugs 플러그인 추가
- Google Java Format 또는 Eclipse Code Formatter 적용
- .editorconfig 파일 추가 (팀 코딩 스타일 통일)

#### API Endpoints

| Method | Endpoint         | Description            |
| ------ | ---------------- | ---------------------- |
| GET    | /api/health      | Health check           |
| GET    | /actuator/health | Spring Actuator health |

#### Error Handling

- 서버 실행 실패 시 로그로 원인 확인 가능해야 함
- 데이터베이스 연결 실패 시 명확한 에러 메시지 제공

#### Acceptance Criteria

- [x] Spring Boot 애플리케이션이 로컬에서 정상 실행됨 (포트 8080)
- [x] `/api/health` 엔드포인트 호출 시 200 OK 응답 반환
- [x] 환경 변수가 올바르게 로드되고 애플리케이션에 적용됨
- [x] Gradle 빌드가 성공하고 JAR 파일이 생성됨
- [x] 프로필별 설정 파일이 정상 작동함 (dev, staging, prod)

---

### [BE-002] JPA Entity 설계 및 PostgreSQL 스키마 구축

**Priority**: 🔴 Critical
**Estimated Time**: 12 hours

#### Description

PostgreSQL 데이터베이스를 구축하고 Spring Data JPA를 사용하여 전체 도메인 Entity를 설계합니다. Hibernate의 DDL 자동 생성 기능을 활용하되, 프로덕션에서는 Flyway 또는 Liquibase를 사용한 마이그레이션을 고려합니다.

#### Functional Requirements

**1. PostgreSQL 데이터베이스 구축**

- PostgreSQL 15 이상 버전 사용
- 로컬 개발: Docker Compose로 PostgreSQL 컨테이너 실행
- 데이터베이스 이름: `esonge_db` (개발), `esonge_test` (테스트)
- 타임존: Asia/Seoul (또는 UTC 사용 후 애플리케이션 레벨에서 변환)
- 문자 인코딩: UTF-8

**2. JPA Entity 설계 원칙**
모든 Entity는 다음 규칙을 따릅니다:

- `@Entity` 어노테이션 사용
- `@Table(name = "테이블명")` 명시 (Snake Case 권장: users, cart_items)
- 기본 키는 `@Id @GeneratedValue(strategy = GenerationType.IDENTITY)` 사용
- 모든 Entity에 생성일시(`createdAt`), 수정일시(`updatedAt`) 필드 추가
  - `@CreatedDate`, `@LastModifiedDate` (Spring Data JPA Auditing 활용)
- Soft Delete가 필요한 Entity는 `deletedAt` 필드 추가 (예: User, Product)
- 연관 관계는 명확하게 정의 (`@OneToMany`, `@ManyToOne`, `@ManyToMany`)
- Lazy Loading 기본 사용, 필요시 Eager Loading

**3. Entity 목록 및 설계 요구사항**

**User Entity (users 테이블)**

- 회원 정보 저장
- 필드: id (PK), email (UNIQUE, NOT NULL), passwordHash, name, phone (UNIQUE), phoneVerified (boolean), membershipTier (enum: BASIC/VIP/WHOLESALE), profileImageUrl, createdAt, updatedAt, deletedAt
- 인덱스: email, phone
- 연관 관계: Address (1:N), CartItem (1:N), MileageTransaction (1:N), DepositTransaction (1:N)

**Address Entity (addresses 테이블)**

- 배송지 정보
- 필드: id (PK), userId (FK), recipientName, phone, postalCode, address, detailAddress, isDefault (boolean), createdAt, updatedAt
- 인덱스: userId
- 연관 관계: User (N:1)
- 비즈니스 규칙: 한 사용자는 최대 10개 배송지, 기본 배송지는 1개만 가능

**Category Entity (categories 테이블)**

- 상품 카테고리 (계층 구조 지원)
- 필드: id (PK), parentId (FK, self-reference), name, slug (UNIQUE), description, displayOrder, isActive, createdAt, updatedAt
- 인덱스: parentId, slug
- 연관 관계: 자기 자신 (parent), Product (1:N)
- 비즈니스 규칙: 최대 3단계 깊이

**Product Entity (products 테이블)**

- 상품 정보
- 필드: id (PK), categoryId (FK), name, slug (UNIQUE), description, price, salePrice, wholesalePrice, stockQuantity, origin (원산지), grade (등급), weight (중량), packaging (포장 단위), isFeatured, isNew, isBest, viewCount, soldCount, ratingAverage, reviewCount, isActive, createdAt, updatedAt
- 인덱스: categoryId, slug, isFeatured, isBest
- 연관 관계: Category (N:1), ProductImage (1:N)

**ProductImage Entity (product_images 테이블)**

- 상품 이미지 (다중 이미지 지원)
- 필드: id (PK), productId (FK), imageUrl, altText, displayOrder, createdAt
- 인덱스: productId
- 연관 관계: Product (N:1)
- 비즈니스 규칙: 첫 번째 이미지(displayOrder=0)가 대표 이미지

**MileageTransaction Entity (mileage_transactions 테이블)**

- 마일리지 적립/사용 내역
- 필드: id (PK), userId (FK), amount (양수: 적립, 음수: 사용), transactionType (enum: EARN/USE/EXPIRE/REFUND), description, orderId (nullable, FK), createdAt
- 인덱스: userId
- 연관 관계: User (N:1)
- 비즈니스 규칙: 사용자별 마일리지 잔액은 합산 계산 (SUM)

**DepositTransaction Entity (deposit_transactions 테이블)**

- 예치금 충전/사용 내역
- 필드: id (PK), userId (FK), amount, transactionType (enum: CHARGE/USE/REFUND), description, orderId (nullable, FK), createdAt
- 인덱스: userId
- 연관 관계: User (N:1)

**CartItem Entity (cart_items 테이블)**

- 장바구니 아이템
- 필드: id (PK), userId (FK, nullable), sessionId (비회원 장바구니), productId (FK), quantity, options (JSON - 등급, 중량 등), createdAt, updatedAt
- 복합 UNIQUE 제약: (userId, productId, options), (sessionId, productId, options)
- 인덱스: userId, sessionId
- 연관 관계: User (N:1), Product (N:1)
- 비즈니스 규칙: 비회원은 sessionId로 관리, 로그인 시 merge 필요

**4. JPA Auditing 설정**
모든 Entity의 createdAt, updatedAt을 자동으로 관리하기 위해:

- `@EnableJpaAuditing` 활성화
- BaseEntity 추상 클래스 생성 (createdAt, updatedAt 포함)
- 모든 Entity가 BaseEntity 상속

**5. 데이터베이스 마이그레이션 전략**

- 개발 환경: `spring.jpa.hibernate.ddl-auto=update` (자동 스키마 생성)
- 스테이징/프로덕션: `ddl-auto=validate` + Flyway 마이그레이션 스크립트 사용 고려

**6. 시드 데이터 준비**
애플리케이션 시작 시 CommandLineRunner 또는 @PostConstruct를 사용하여 테스트 데이터 삽입:

- 카테고리 3개 (채소, 과일, 곡물)
- 상품 10개 (각 카테고리별 3-4개)
- 테스트 사용자 1명 (email: test@example.com)

#### Error Handling

- 데이터베이스 연결 실패 시 애플리케이션 시작 중단 및 로그 출력
- Entity 제약 조건 위반 시 ConstraintViolationException 처리
- 중복 email/phone 가입 시 DataIntegrityViolationException 처리

#### Acceptance Criteria

- [x] PostgreSQL 데이터베이스가 생성되고 연결됨
- [x] 모든 JPA Entity 클래스가 작성되고 테이블이 자동 생성됨
- [x] JPA Repository 인터페이스가 각 Entity별로 생성됨 (예: UserRepository extends JpaRepository<User, Long>)
- [x] Auditing이 활성화되어 createdAt, updatedAt이 자동 설정됨
- [x] 시드 데이터가 정상적으로 삽입됨
- [x] JPA 쿼리를 통해 데이터 조회가 가능함 (예: userRepository.findByEmail())

---

### [BE-003] SpringDoc OpenAPI (Swagger) 문서화 시스템 구축

**Priority**: 🔴 Critical
**Estimated Time**: 6 hours

#### Description

SpringDoc OpenAPI 라이브러리를 사용하여 자동 API 문서화 시스템을 구축합니다. 프론트엔드 팀이 Swagger UI를 통해 API 명세를 확인하고 테스트할 수 있도록 합니다.

#### Functional Requirements

**1. SpringDoc OpenAPI 의존성 추가**

- `springdoc-openapi-starter-webmvc-ui` 라이브러리 추가
- Spring Boot 3.x와 호환되는 최신 버전 사용

**2. OpenAPI 기본 설정**
OpenAPI 문서의 메타 정보를 정의합니다:

- 제목: "Esonge Shopping Mall API"
- 버전: "1.0.0"
- 설명: "API for Esonge premium agricultural products e-commerce platform"
- 서버 URL:
  - Development: http://localhost:8080
  - Staging: https://staging-api.esonge.co.kr
  - Production: https://api.esonge.co.kr (추후)

**3. Swagger UI 엔드포인트**
다음 엔드포인트가 자동으로 생성되어야 합니다:

- `/swagger-ui.html` - Swagger UI 페이지
- `/v3/api-docs` - OpenAPI JSON 스펙
- `/v3/api-docs.yaml` - OpenAPI YAML 스펙

**4. 공통 스키마 정의**
다음 공통 응답 포맷을 문서화합니다:

**성공 응답:**

```
{
  "success": true,
  "data": { ... },
  "meta": {
    "pagination": {
      "page": 1,
      "limit": 16,
      "totalPages": 5,
      "totalItems": 80
    }
  }
}
```

**에러 응답:**

```
{
  "success": false,
  "error": {
    "code": "ERROR_CODE",
    "message": "Human readable error message"
  }
}
```

**페이지네이션 파라미터 (공통):**

- page (query parameter, default: 1)
- limit (query parameter, default: 16, max: 100)
- sort (query parameter, example: "createdAt:desc")

**5. API 태그(Tag) 정의**
API를 논리적 그룹으로 분류합니다:

- System - 헬스 체크, 정보
- Auth - 인증/인가 (Week 3-4에서 추가)
- Users - 사용자 관리
- Products - 상품 관리
- Categories - 카테고리 관리
- Cart - 장바구니
- Orders - 주문
- Reviews - 리뷰
- QA - 상품 Q&A

**6. 헬스 체크 엔드포인트 문서화 예시**
`GET /api/health` 엔드포인트를 다음과 같이 문서화합니다:

- Summary: "Health check endpoint"
- Tag: "System"
- Response 200: `{ "status": "ok", "timestamp": "2024-01-15T10:30:00Z" }`
- Controller에 `@Operation`, `@ApiResponse` 어노테이션 사용

**7. 보안 스키마 정의 (Week 3-4에서 사용)**
JWT Bearer 토큰 인증을 위한 보안 스키마 정의:

- securitySchemes: bearerAuth (HTTP Bearer)
- 인증이 필요한 엔드포인트는 `@SecurityRequirement` 어노테이션 추가

**8. DTO 클래스 문서화**
Request/Response DTO에 다음 어노테이션 추가:

- `@Schema(description = "...")` - 필드 설명
- `@NotNull`, `@Email`, `@Size` 등 Validation 어노테이션 (자동 문서화)

#### API Endpoints

| Method | Endpoint          | Description       |
| ------ | ----------------- | ----------------- |
| GET    | /swagger-ui.html  | Swagger UI 페이지 |
| GET    | /v3/api-docs      | OpenAPI JSON 스펙 |
| GET    | /v3/api-docs.yaml | OpenAPI YAML 스펙 |

#### Error Handling

- Swagger UI 접근 실패 시 404가 아닌 올바른 경로 안내
- API 문서 생성 실패 시 로그에 상세 에러 출력

#### Acceptance Criteria

- [x] `/swagger-ui.html`에 접속하면 Swagger UI가 표시됨
- [x] Health check 엔드포인트가 Swagger에 문서화되어 표시됨
- [x] "Try it out" 기능으로 API를 직접 테스트할 수 있음
- [x] 공통 응답 스키마가 정의되어 재사용 가능함
- [x] 프론트엔드 팀이 Swagger UI를 통해 API 명세를 확인할 수 있음

---

### [BE-004] Logback 기반 구조화된 로깅 시스템 구축

**Priority**: 🟡 High
**Estimated Time**: 4 hours

#### Description

SLF4J와 Logback을 사용하여 구조화된 로깅 시스템을 구축합니다. JSON 포맷 로그를 출력하고, 파일 로테이션을 설정하여 운영 환경에서 로그 관리를 용이하게 합니다.

#### Functional Requirements

**1. 로깅 프레임워크 선택**

- Spring Boot 기본 로깅: SLF4J + Logback (별도 의존성 추가 불필요)
- 추가 고려: logstash-logback-encoder (JSON 포맷 로그 출력)

**2. 로그 레벨 정의**
다음 로그 레벨을 환경별로 설정합니다:

- TRACE: 매우 상세한 정보 (거의 사용 안 함)
- DEBUG: 디버깅 정보 (개발 환경에서만 사용)
- INFO: 일반 정보 (주요 비즈니스 로직 실행 정보)
- WARN: 경고 (잠재적 문제)
- ERROR: 에러 (예외 발생, 스택 트레이스 포함)

환경별 로그 레벨:

- Development: DEBUG
- Staging: INFO
- Production: WARN

**3. 로그 출력 포맷**
로그는 JSON 포맷으로 출력하여 로그 분석 도구(ELK Stack 등)와 호환되도록 합니다:

필수 필드:

- timestamp (ISO 8601 형식)
- level (로그 레벨)
- logger (로거 이름, 패키지.클래스명)
- message (로그 메시지)
- thread (스레드 이름)
- context (optional) - userId, requestId, ip 등 컨텍스트 정보

에러 로그 추가 필드:

- exception (예외 클래스명)
- stackTrace (스택 트레이스)

**4. 로그 파일 로테이션 전략**
로그 파일은 다음 규칙에 따라 로테이션됩니다:

- 일별 로테이션: 매일 자정에 새 파일 생성 (application-2024-01-15.log)
- 크기별 로테이션: 파일 크기가 100MB 초과 시 새 파일 생성
- 보관 기간: 최근 30일 로그만 유지, 이후 자동 삭제
- 로그 파일 경로: `logs/` 디렉토리 (프로젝트 루트 또는 /var/log/esonge/)

**5. HTTP 요청/응답 로깅**
다음 정보를 포함한 HTTP 로깅 필터를 구현합니다:

- 요청 메서드 (GET, POST, PUT, DELETE)
- 요청 URL
- 요청 헤더 (Authorization 제외, 민감 정보 마스킹)
- 요청 본문 (크기 제한: 1KB, 민감 정보 마스킹)
- 응답 상태 코드
- 응답 시간 (ms)
- 클라이언트 IP
- User-Agent

로그 레벨: INFO (성공), WARN (4xx), ERROR (5xx)

**6. 에러 로깅**
모든 예외는 다음 정보와 함께 로깅됩니다:

- 예외 메시지
- 예외 타입
- 전체 스택 트레이스
- 요청 URL 및 메서드
- 사용자 ID (인증된 경우)

**7. 패키지별 로그 레벨 세분화**
다양한 패키지에 대해 로그 레벨을 개별 설정:

- com.esonge: DEBUG (개발), INFO (운영)
- org.springframework: INFO
- org.hibernate.SQL: DEBUG (개발), OFF (운영)
- org.hibernate.type.descriptor.sql: TRACE (개발, SQL 파라미터 확인), OFF (운영)

**8. 민감 정보 마스킹**
다음 정보는 로그에 출력 시 마스킹 처리:

- 비밀번호 (password, passwordHash)
- JWT 토큰 (Authorization 헤더)
- 카드 번호
- 전화번호 (뒤 4자리 제외 마스킹)

#### Error Handling

- 로그 파일 쓰기 실패 시에도 애플리케이션은 계속 실행되어야 함
- 로그 디렉토리 권한 문제 시 콘솔로 로그 출력

#### Acceptance Criteria

- [x] 모든 HTTP 요청이 로그에 기록됨 (메서드, URL, 응답 시간 포함)
- [x] 예외 발생 시 스택 트레이스가 로그에 기록됨
- [x] 로그 파일이 일별/크기별로 자동 로테이션됨
- [x] 개발 환경에서는 콘솔에 컬러풀한 로그가 출력됨
- [x] 프로덕션 환경에서는 JSON 포맷 로그 파일이 생성됨
- [x] 민감 정보가 로그에 노출되지 않음

---

### [BE-005] Spring 전역 예외 처리 시스템 구축

**Priority**: 🟡 High
**Estimated Time**: 4 hours

#### Description

`@ControllerAdvice`를 사용하여 일관된 에러 응답 포맷을 제공하고, 커스텀 예외 클래스를 정의하여 비즈니스 로직에서 명확한 예외 처리를 구현합니다.

#### Functional Requirements

**1. 커스텀 예외 클래스 계층 구조**
다음 예외 클래스를 정의합니다:

**BaseException (추상 클래스)**

- 모든 커스텀 예외의 부모 클래스
- 필드: message (에러 메시지), statusCode (HTTP 상태 코드), errorCode (에러 코드 문자열)
- RuntimeException 상속

**구체적인 예외 클래스:**

- ValidationException - 입력값 검증 실패 (400 BAD_REQUEST, "VALIDATION_ERROR")
- UnauthorizedException - 인증 실패 (401 UNAUTHORIZED, "UNAUTHORIZED")
- ForbiddenException - 권한 없음 (403 FORBIDDEN, "FORBIDDEN")
- NotFoundException - 리소스 없음 (404 NOT_FOUND, "NOT_FOUND")
- ConflictException - 중복 리소스 (409 CONFLICT, "CONFLICT")
- InternalServerException - 서버 내부 오류 (500 INTERNAL_SERVER_ERROR, "INTERNAL_SERVER_ERROR")

**2. 에러 코드 정의**
각 에러 상황에 대해 명확한 에러 코드를 정의합니다:

- VALIDATION_ERROR - 입력값 검증 실패
- EMAIL_ALREADY_EXISTS - 이메일 중복
- PHONE_ALREADY_EXISTS - 전화번호 중복
- USER_NOT_FOUND - 사용자를 찾을 수 없음
- PRODUCT_NOT_FOUND - 상품을 찾을 수 없음
- PRODUCT_OUT_OF_STOCK - 재고 부족
- UNAUTHORIZED - 인증 실패
- FORBIDDEN - 권한 없음
- INVALID_TOKEN - 유효하지 않은 토큰
- TOKEN_EXPIRED - 토큰 만료
- INTERNAL_SERVER_ERROR - 서버 내부 오류

**3. 전역 예외 핸들러 (@ControllerAdvice)**
GlobalExceptionHandler 클래스를 작성하여 다음 예외를 처리합니다:

**처리할 예외 타입:**

- 커스텀 예외 (BaseException 및 하위 클래스)
- MethodArgumentNotValidException (Bean Validation 실패)
- ConstraintViolationException (JPA 제약 조건 위반)
- DataIntegrityViolationException (DB 무결성 제약 위반, 예: 중복 email)
- HttpMessageNotReadableException (잘못된 JSON 형식)
- MissingServletRequestParameterException (필수 파라미터 누락)
- Exception (모든 기타 예외 - 500 응답)

**4. 에러 응답 포맷**
모든 에러 응답은 다음 JSON 포맷을 따릅니다:

```json
{
  "success": false,
  "error": {
    "code": "ERROR_CODE",
    "message": "사용자에게 표시할 에러 메시지"
  }
}
```

개발 환경(dev)에서만 스택 트레이스 추가:

```json
{
  "success": false,
  "error": {
    "code": "ERROR_CODE",
    "message": "에러 메시지",
    "stackTrace": "..."
  }
}
```

**5. Validation 에러 상세 정보**
Bean Validation 실패 시 어떤 필드에서 어떤 문제가 발생했는지 상세 정보를 제공합니다:

```json
{
  "success": false,
  "error": {
    "code": "VALIDATION_ERROR",
    "message": "입력값 검증에 실패했습니다.",
    "details": [
      {
        "field": "email",
        "message": "이메일 형식이 올바르지 않습니다."
      },
      {
        "field": "password",
        "message": "비밀번호는 최소 8자 이상이어야 합니다."
      }
    ]
  }
}
```

**6. HTTP 상태 코드 매핑**
각 예외 타입에 적절한 HTTP 상태 코드를 매핑합니다:

- ValidationException → 400 BAD_REQUEST
- UnauthorizedException → 401 UNAUTHORIZED
- ForbiddenException → 403 FORBIDDEN
- NotFoundException → 404 NOT_FOUND
- ConflictException → 409 CONFLICT
- InternalServerException → 500 INTERNAL_SERVER_ERROR
- 기타 모든 예외 → 500 INTERNAL_SERVER_ERROR

**7. 에러 로깅 전략**

- 4xx 에러: WARN 레벨로 로깅 (클라이언트 실수)
- 5xx 에러: ERROR 레벨로 로깅, 스택 트레이스 포함 (서버 문제)

**8. 에러 메시지 국제화 고려 (Optional)**
추후 다국어 지원을 위해 MessageSource를 활용한 에러 메시지 국제화 기반 마련

#### Error Handling

- 예외 핸들러 자체에서 예외 발생 시 기본 500 응답 반환
- 순환 참조 방지 (JSON 직렬화 시)

#### Acceptance Criteria

- [x] 모든 API 에러가 일관된 JSON 포맷으로 응답됨
- [x] 커스텀 예외를 던지면 정의된 상태 코드와 에러 코드가 반환됨
- [x] Bean Validation 실패 시 필드별 에러 상세 정보가 제공됨
- [x] 개발 환경에서는 스택 트레이스가 포함되고, 프로덕션에서는 제외됨
- [x] 예외 발생 시 로그에 적절한 레벨로 기록됨
- [x] 프론트엔드가 에러 코드를 기반으로 사용자 친화적 메시지를 표시할 수 있음

---

### [BE-006] GitHub Actions CI/CD 및 Docker 설정

**Priority**: 🟡 High
**Estimated Time**: 6 hours

#### Description

자동화된 테스트 및 빌드 파이프라인을 구축하고, Docker를 사용한 컨테이너화 환경을 설정합니다. 로컬 개발 환경은 Docker Compose로 간편하게 구축할 수 있도록 합니다.

#### Functional Requirements

**1. GitHub Actions Workflow 설정**
`.github/workflows/backend-ci.yml` 파일을 작성하여 다음 작업을 자동화합니다:

**트리거 조건:**

- main 브랜치에 push
- develop 브랜치에 push
- main/develop 브랜치로의 Pull Request 생성

**CI 작업 단계:**

1. 코드 체크아웃
2. Java 17 설치 (Temurin 또는 Adopt OpenJDK)
3. Gradle 캐싱 (빌드 속도 향상)
4. Gradle 빌드 (`./gradlew build`)
5. 단위 테스트 실행 (`./gradlew test`)
6. Checkstyle 실행 (코드 스타일 검사)
7. 테스트 커버리지 리포트 생성 (JaCoCo)
8. 빌드 아티팩트 업로드 (JAR 파일)

**서비스 컨테이너:**

- PostgreSQL 15 (테스트용 DB)
  - 환경 변수: POSTGRES_DB=esonge_test, POSTGRES_USER=postgres, POSTGRES_PASSWORD=postgres
  - Health check 설정
- Redis 7 (테스트용 캐시)

**환경 변수 (GitHub Secrets):**

- DB_HOST=localhost
- DB_PORT=5432
- DB_NAME=esonge_test
- DB_USERNAME=postgres
- DB_PASSWORD=postgres
- REDIS_HOST=localhost
- REDIS_PORT=6379

**2. Dockerfile 작성**
애플리케이션을 컨테이너화하기 위한 Dockerfile을 작성합니다:

**빌드 전략: Multi-stage Build**

- Stage 1 (Builder): Gradle을 사용하여 JAR 파일 빌드
  - Base image: gradle:8-jdk17
  - 소스 코드 복사
  - `./gradlew bootJar` 실행
- Stage 2 (Runtime): 빌드된 JAR 파일로 실행 이미지 생성
  - Base image: eclipse-temurin:17-jre-alpine (가벼운 이미지)
  - JAR 파일만 복사
  - 포트 8080 노출
  - 애플리케이션 실행

**최적화:**

- .dockerignore 파일 작성 (build/, .gradle/, .git/ 제외)
- 레이어 캐싱 활용 (의존성 다운로드 레이어 분리)

**3. Docker Compose 설정 (로컬 개발용)**
`docker-compose.yml` 파일을 작성하여 다음 서비스를 정의합니다:

**서비스 구성:**

- postgres: PostgreSQL 15
  - 포트: 5432
  - 볼륨: postgres_data (데이터 영속성)
  - 환경 변수: POSTGRES_DB, POSTGRES_USER, POSTGRES_PASSWORD
  - Health check

- redis: Redis 7 Alpine
  - 포트: 6379
  - 볼륨: redis_data (선택 사항)

- app: Spring Boot 애플리케이션
  - 빌드: 현재 디렉토리의 Dockerfile
  - 포트: 8080:8080
  - 환경 변수: DB_HOST=postgres, REDIS_HOST=redis, SPRING_PROFILES_ACTIVE=dev
  - depends_on: postgres, redis (서비스 시작 순서)
  - 볼륨: 소스 코드 마운트 (핫 리로드 지원, 개발 환경)

**사용법:**

- `docker-compose up -d` - 모든 서비스 시작
- `docker-compose logs -f app` - 애플리케이션 로그 확인
- `docker-compose down` - 모든 서비스 종료

**4. 테스트 설정**

- JUnit 5 기반 단위 테스트
- Spring Boot Test (@SpringBootTest) 통합 테스트
- Testcontainers (선택 사항) - 실제 PostgreSQL/Redis 컨테이너로 테스트
- 테스트 커버리지 목표: 70% 이상

**5. 환경별 Docker Compose 파일 (선택 사항)**

- docker-compose.dev.yml (개발)
- docker-compose.staging.yml (스테이징)

#### API Endpoints

해당 없음 (인프라 설정)

#### Error Handling

- CI 파이프라인 실패 시 GitHub 알림
- Docker 빌드 실패 시 명확한 에러 메시지

#### Acceptance Criteria

- [x] Pull Request 생성 시 자동으로 테스트가 실행됨
- [x] 모든 테스트가 통과하면 빌드가 성공함
- [x] Docker Compose로 로컬 환경을 한 번에 구축할 수 있음 (DB + Redis + App)
- [x] `docker-compose up` 실행 후 `http://localhost:8080/api/health` 접속 시 200 응답
- [x] JAR 파일이 빌드 아티팩트로 생성됨
- [x] CI 파이프라인이 5분 이내에 완료됨

---

### [BE-007] Spring Data Redis 캐싱 시스템 구축

**Priority**: 🟢 Medium
**Estimated Time**: 4 hours

#### Description

Redis를 활용한 캐싱 시스템을 구축하여 데이터베이스 부하를 줄이고 응답 속도를 향상시킵니다. Spring Cache Abstraction을 사용하여 선언적 캐싱을 구현합니다.

#### Functional Requirements

**1. Redis 의존성 및 설정**

- spring-boot-starter-data-redis 의존성 추가
- spring-boot-starter-cache 의존성 추가

**2. Redis 연결 설정**
application.yml에 Redis 연결 정보를 설정합니다:

- Host (기본: localhost)
- Port (기본: 6379)
- Password (프로덕션 환경에서 필수)
- Connection Timeout
- Connection Pool 설정 (최대 연결 수, Idle 연결 수)

**3. RedisTemplate 설정**
다음 RedisTemplate을 Bean으로 등록합니다:

- RedisTemplate<String, Object> - 범용 템플릿
- StringRedisTemplate - 문자열 전용 (기본 제공)

**직렬화 설정:**

- Key: StringRedisSerializer (문자열)
- Value: GenericJackson2JsonRedisSerializer (JSON)
- Hash Key: StringRedisSerializer
- Hash Value: GenericJackson2JsonRedisSerializer

**4. Spring Cache 활성화**

- @EnableCaching 어노테이션 추가
- RedisCacheManager Bean 등록
- 기본 TTL(Time To Live) 설정

**5. 캐시 전략 정의**
다음 데이터에 대한 캐시 전략을 수립합니다:

**캐시할 데이터:**

- 상품 목록 (캐시 이름: "products", TTL: 5분)
- 상품 상세 (캐시 이름: "product", TTL: 10분)
- 카테고리 목록 (캐시 이름: "categories", TTL: 1시간)
- 베스트 상품 (캐시 이름: "bestProducts", TTL: 10분)
- 신상품 (캐시 이름: "newProducts", TTL: 10분)

**캐시 키 전략:**

- 상품 목록: `products::page:{page}:limit:{limit}:category:{categoryId}`
- 상품 상세: `product::{productId}`
- 카테고리 목록: `categories::all`

**6. 캐싱 어노테이션 사용**
Service 레이어 메서드에 다음 어노테이션을 적용합니다:

- @Cacheable - 캐시 조회 (없으면 메서드 실행 후 캐시 저장)
- @CachePut - 캐시 갱신 (항상 메서드 실행 후 결과 저장)
- @CacheEvict - 캐시 삭제 (상품 수정/삭제 시)

**예시 사용 케이스:**

- ProductService.getProductById(Long id) → @Cacheable
- ProductService.updateProduct(Long id, ...) → @CacheEvict
- ProductService.deleteProduct(Long id) → @CacheEvict

**7. 캐시 헬퍼 유틸리티**
다음 기능을 제공하는 CacheUtil 클래스를 작성합니다:

- getOrSetCache(String key, Supplier<T> fetchFunction, long ttl) - 캐시 조회 또는 설정
- evictCache(String key) - 특정 키 캐시 삭제
- evictCachesByPattern(String pattern) - 패턴 매칭 캐시 삭제 (예: `products::*`)

**8. 세션 관리 (Week 3-4에서 본격 사용)**
Redis를 세션 스토어로 사용할 수 있도록 기반을 마련합니다:

- spring-session-data-redis 의존성 추가
- @EnableRedisHttpSession 어노테이션 (Week 3-4에서 활성화)

**9. Redis 연결 모니터링**

- Redis 연결 성공/실패 로그 출력
- Health check에 Redis 상태 포함 (`/actuator/health` 응답에 redis 항목)

**10. 캐시 워밍업 (선택 사항)**
애플리케이션 시작 시 자주 사용되는 데이터를 미리 캐시에 로드:

- 카테고리 목록
- 베스트 상품 16개
- 신상품 16개

#### Error Handling

- Redis 연결 실패 시에도 애플리케이션은 계속 실행되어야 함 (캐시 없이 동작)
- 캐시 조회 실패 시 원본 데이터 소스에서 조회
- Redis 직렬화/역직렬화 실패 시 로그 출력 및 캐시 스킵

#### Acceptance Criteria

- [x] Redis 연결이 성공적으로 이루어짐
- [x] @Cacheable 어노테이션을 사용한 메서드 호출 시 캐시가 동작함
- [x] 동일한 요청을 반복하면 두 번째 요청부터는 캐시에서 조회됨 (DB 쿼리 없음)
- [x] 상품 수정/삭제 시 관련 캐시가 자동으로 삭제됨
- [x] `/actuator/health` 응답에 Redis 상태가 포함됨
- [x] Redis 연결 실패 시에도 애플리케이션이 정상 실행됨 (캐시 비활성화)

---

### [BE-008] 환경별 설정 관리 (Spring Profiles)

**Priority**: 🟡 High
**Estimated Time**: 3 hours

#### Description

개발(dev), 스테이징(staging), 프로덕션(prod) 환경별로 설정을 분리하여 관리합니다. Spring Profiles를 활용하여 환경에 맞는 설정이 자동으로 로드되도록 합니다.

#### Functional Requirements

**1. Spring Profiles 정의**
다음 3개의 프로필을 정의합니다:

- dev (개발 환경)
- staging (스테이징 환경)
- prod (프로덕션 환경)

**2. 설정 파일 구조**
`src/main/resources/` 디렉토리에 다음 파일을 생성합니다:

- application.yml - 공통 설정 (모든 프로필에서 공유)
- application-dev.yml - 개발 환경 설정
- application-staging.yml - 스테이징 환경 설정
- application-prod.yml - 프로덕션 환경 설정

**3. 공통 설정 (application.yml)**
모든 환경에서 공통으로 사용하는 설정:

- 서버 포트: 8080
- 애플리케이션 이름: esonge-backend
- JPA 공통 설정 (naming strategy, open-in-view)
- Jackson JSON 직렬화 설정 (날짜 포맷, null 제외 등)
- Multipart 파일 업로드 설정 (최대 파일 크기)

**4. 개발 환경 설정 (application-dev.yml)**

- 데이터베이스:
  - URL: jdbc:postgresql://localhost:5432/esonge_db
  - JPA ddl-auto: update (자동 스키마 생성)
  - show-sql: true (SQL 쿼리 로그 출력)
  - format_sql: true (SQL 포맷팅)
- Redis: localhost:6379
- 로깅 레벨: DEBUG (com.esonge 패키지)
- CORS: 모든 도메인 허용 (http://localhost:3000)
- Swagger UI: 활성화

**5. 스테이징 환경 설정 (application-staging.yml)**

- 데이터베이스:
  - URL: 환경 변수에서 로드 (${DB_HOST}, ${DB_PORT}, ${DB_NAME})
  - JPA ddl-auto: validate
  - show-sql: false
- Redis: 환경 변수에서 로드
- 로깅 레벨: INFO
- CORS: 프론트엔드 스테이징 도메인만 허용
- Swagger UI: 활성화 (비밀번호 보호 고려)

**6. 프로덕션 환경 설정 (application-prod.yml)**

- 데이터베이스:
  - URL: 환경 변수에서 로드
  - JPA ddl-auto: validate (절대 update/create 사용 금지)
  - show-sql: false
- Redis: 환경 변수에서 로드 (비밀번호 필수)
- 로깅 레벨: WARN
- CORS: 프론트엔드 프로덕션 도메인만 허용
- Swagger UI: 비활성화 (보안)
- HTTPS 강제

**7. 환경 변수 관리**
민감한 정보는 코드에 하드코딩하지 않고 환경 변수로 관리합니다:

**필수 환경 변수:**

- SPRING_PROFILES_ACTIVE (dev/staging/prod)
- DB_HOST
- DB_PORT
- DB_NAME
- DB_USERNAME
- DB_PASSWORD
- REDIS_HOST
- REDIS_PORT
- REDIS_PASSWORD (staging/prod)
- JWT_SECRET (Week 3-4에서 사용)
- AWS_ACCESS_KEY_ID (Week 5 이후 S3 사용)
- AWS_SECRET_ACCESS_KEY (Week 5 이후 S3 사용)

**8. .env.example 파일 작성**
팀원이 로컬 환경 설정을 쉽게 할 수 있도록 예제 파일을 제공합니다:

```
SPRING_PROFILES_ACTIVE=dev
DB_HOST=localhost
DB_PORT=5432
DB_NAME=esonge_db
DB_USERNAME=postgres
DB_PASSWORD=postgres
REDIS_HOST=localhost
REDIS_PORT=6379
JWT_SECRET=your-secret-key-here
```

**9. 프로필 활성화 방법**
다양한 방법으로 프로필을 활성화할 수 있습니다:

- 환경 변수: `export SPRING_PROFILES_ACTIVE=dev`
- JVM 옵션: `java -jar app.jar --spring.profiles.active=dev`
- application.yml 기본값: `spring.profiles.default=dev`
- IDE 설정 (IntelliJ, Eclipse)

**10. 프로필별 Bean 등록 (선택 사항)**
@Profile 어노테이션을 사용하여 특정 프로필에서만 Bean을 등록할 수 있습니다:

- @Profile("dev") - 개발 환경에서만 등록 (예: 시드 데이터 로더)
- @Profile("!prod") - 프로덕션이 아닌 환경에서만 등록 (예: Swagger 설정)

#### Error Handling

- 프로필이 설정되지 않으면 기본 프로필(dev) 사용
- 필수 환경 변수 누락 시 애플리케이션 시작 실패 및 명확한 에러 메시지

#### Acceptance Criteria

- [x] 각 환경에서 올바른 프로필 설정이 로드됨
- [x] 개발 환경에서는 SQL 쿼리 로그가 출력되고, 프로덕션에서는 출력되지 않음
- [x] 민감한 정보가 설정 파일에 하드코딩되지 않고 환경 변수로 관리됨
- [x] .env.example 파일이 제공되어 팀원이 쉽게 환경을 설정할 수 있음
- [x] `SPRING_PROFILES_ACTIVE` 환경 변수 변경만으로 프로필 전환 가능
- [x] 프로덕션 환경에서는 Swagger UI가 비활성화됨

---

## 📊 Week 1-2 Summary

### Deliverables

- ✅ Spring Boot 프로젝트 초기 설정 완료 (Gradle, Java 17, Spring Boot 3.x)
- ✅ JPA Entity 설계 및 PostgreSQL 데이터베이스 스키마 구축
- ✅ SpringDoc OpenAPI (Swagger) 문서화 시스템 구축
- ✅ Logback 기반 구조화된 로깅 시스템
- ✅ @ControllerAdvice 전역 예외 처리 시스템
- ✅ GitHub Actions CI/CD 파이프라인 및 Docker 설정
- ✅ Spring Data Redis 캐싱 시스템
- ✅ 환경별 설정 관리 (Spring Profiles)

### Key Endpoints (Week 1-2)

| Method | Endpoint         | Description            |
| ------ | ---------------- | ---------------------- |
| GET    | /api/health      | Health check           |
| GET    | /actuator/health | Spring Actuator health |
| GET    | /swagger-ui.html | Swagger UI             |
| GET    | /v3/api-docs     | OpenAPI JSON           |

### Database Schema

8개의 핵심 Entity가 생성됨:

- User (회원)
- Address (배송지)
- Category (카테고리)
- Product (상품)
- ProductImage (상품 이미지)
- MileageTransaction (마일리지 거래)
- DepositTransaction (예치금 거래)
- CartItem (장바구니)

### Infrastructure

- PostgreSQL 15+ (JPA로 관리)
- Redis 7+ (캐싱 및 세션)
- Docker & Docker Compose (로컬 개발)
- GitHub Actions (CI/CD)

### Next Steps (Week 3-4)

- Spring Security + JWT 인증 시스템 구현
- 회원가입, 로그인, 토큰 갱신 API (로컬 JWT만, 외부 API 제외)
- 사용자 프로필 관리 API
- 배송지 CRUD API
- 비밀번호 변경 API
- 계정 삭제 API (Soft Delete)

**Note**: 외부 API 연동(소셜 로그인, SMS, 이메일)은 Week 22-25로 연기되었습니다. Week 1-21은 로컬 개발에 집중합니다.

---

**Documentation Style**: 이 문서는 명시적인 코드 예시 없이 기능 요구사항을 텍스트로 상세히 설명하는 방식으로 작성되었습니다. 개발자는 이 요구사항을 읽고 Java/Spring Boot 기반으로 직접 구현할 수 있습니다.
