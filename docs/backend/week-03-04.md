# Week 3-4: Spring Security + JWT 인증 시스템 (로컬 전용)

**기간**: Week 3-4
**목표**: Spring Security + JWT 기반 로컬 인증 시스템 구현, 사용자 프로필 관리 API 구현
**기술 스택**: Spring Security 6.x, JWT (jjwt), BCrypt, Spring Data JPA
**프론트엔드 연동**: Week 4부터 시작
**중요**: 외부 API 연동(소셜 로그인, SMS, 이메일)은 Week 22-25로 연기. 이번 주는 로컬 JWT 인증만 구현.

---

## 📋 Issue Tickets

### [BE-009] Spring Security + JWT 인증 시스템 기반 구축

**Priority**: 🔴 Critical
**Estimated Time**: 8 hours

#### Description

Spring Security를 설정하고 JWT(JSON Web Token) 기반 인증 시스템의 기반을 구축합니다. Access Token과 Refresh Token 두 가지를 사용하여 보안성과 사용자 경험을 모두 향상시킵니다.

#### Functional Requirements

**1. JWT 라이브러리 의존성 추가**

- `io.jsonwebtoken:jjwt-api` (JWT API)
- `io.jsonwebtoken:jjwt-impl` (JWT 구현체)
- `io.jsonwebtoken:jjwt-jackson` (JSON 처리)
- Spring Boot 3.x와 호환되는 최신 버전 사용 (0.11.x 이상)

**2. JWT 토큰 생성 및 검증 유틸리티**
JwtTokenProvider 또는 JwtUtil 클래스를 작성하여 다음 기능을 제공합니다:

**Access Token 생성:**

- Payload: userId, email, roles (현재는 ROLE_USER만 사용)
- Expiration: 1시간
- Signing Key: JWT_SECRET 환경 변수에서 로드 (HS256 알고리즘)

**Refresh Token 생성:**

- Payload: userId (최소한의 정보만 포함)
- Expiration: 7일 (Remember Me 체크 시 30일)
- Signing Key: JWT_REFRESH_SECRET 환경 변수에서 로드

**토큰 검증 기능:**

- verifyAccessToken(String token): 토큰 서명 검증, 만료 확인, Claims 추출
- verifyRefreshToken(String token): Refresh Token 검증
- extractUserId(String token): 토큰에서 userId 추출
- extractEmail(String token): 토큰에서 email 추출
- isTokenExpired(String token): 만료 여부 확인

**3. RefreshToken Entity 및 Repository 생성**
Refresh Token을 데이터베이스에 저장하여 관리합니다:

**RefreshToken Entity (refresh_tokens 테이블):**

- 필드: id (PK), userId (FK to users), token (UNIQUE, NOT NULL, 최대 500자), expiresAt (Timestamp), createdAt
- 인덱스: userId, token
- 비즈니스 규칙: 한 사용자가 여러 디바이스에서 로그인할 수 있도록 여러 Refresh Token 허용

**RefreshTokenRepository:**

- JpaRepository 확장
- 커스텀 메서드: findByToken(String token), deleteByToken(String token), deleteByUserId(Long userId)

**4. Spring Security 설정**
SecurityConfig 클래스를 작성하여 다음을 설정합니다:

**기본 보안 설정:**

- CSRF 비활성화 (REST API이므로)
- Session Management: STATELESS (JWT 사용, 세션 사용 안 함)
- CORS 설정: 프론트엔드 도메인 허용 (http://localhost:3000)

**URL 권한 설정:**

- 인증 불필요 (permitAll):
  - /api/health, /actuator/health
  - /swagger-ui/**, /v3/api-docs/**
  - /api/auth/register, /api/auth/login, /api/auth/refresh
- 인증 필요 (authenticated):
  - /api/users/\*\*, /api/auth/logout
  - 기타 모든 /api/\*\* 엔드포인트

**5. JWT 인증 필터 구현**
JwtAuthenticationFilter 클래스를 작성하여 OncePerRequestFilter를 확장합니다:

**필터 동작:**

1. HTTP 요청에서 Authorization 헤더 추출
2. "Bearer " 접두사 확인 및 토큰 추출
3. JWT 토큰 검증 (유효성, 만료)
4. 토큰에서 userId 추출
5. UserDetailsService를 통해 User 조회
6. SecurityContext에 Authentication 객체 설정
7. 다음 필터로 요청 전달

**예외 처리:**

- 토큰 없음: 인증 없이 다음 필터로 (permitAll 엔드포인트는 접근 가능)
- 토큰 유효하지 않음: 401 Unauthorized 응답
- 토큰 만료: 401 Unauthorized 응답, 에러 코드 TOKEN_EXPIRED

**6. UserDetailsService 구현**
CustomUserDetailsService 클래스를 작성하여 UserDetailsService 인터페이스를 구현합니다:

**loadUserByUsername(String email) 메서드:**

- email로 User Entity 조회
- User가 없으면 UsernameNotFoundException 발생
- deletedAt이 null이 아니면 (탈퇴한 사용자) 예외 발생
- UserDetails 객체 생성 및 반환
  - username: email
  - password: passwordHash
  - authorities: 사용자의 roles (예: ROLE_USER, ROLE_ADMIN)

**7. 비밀번호 인코더 설정**
PasswordEncoder Bean 등록:

- BCryptPasswordEncoder 사용 (strength: 10)
- 회원가입 시 비밀번호 해싱
- 로그인 시 비밀번호 검증

**8. 인증 진입점 및 액세스 거부 핸들러**
인증 실패 시 일관된 JSON 응답을 반환하도록 설정:

**JwtAuthenticationEntryPoint:**

- 인증되지 않은 요청 시 401 응답
- JSON 응답: `{ "success": false, "error": { "code": "UNAUTHORIZED", "message": "..." } }`

**JwtAccessDeniedHandler:**

- 권한 없는 요청 시 403 응답
- JSON 응답: `{ "success": false, "error": { "code": "FORBIDDEN", "message": "..." } }`

#### API Endpoints

해당 없음 (인프라 설정)

#### Error Handling

- JWT 파싱 실패: 401 UNAUTHORIZED, "INVALID_TOKEN"
- JWT 만료: 401 UNAUTHORIZED, "TOKEN_EXPIRED"
- 사용자 없음: 401 UNAUTHORIZED, "USER_NOT_FOUND"

#### Acceptance Criteria

- [x] Spring Security가 정상적으로 설정됨
- [x] JWT 토큰 생성 및 검증 유틸리티가 동작함
- [x] JwtAuthenticationFilter가 모든 요청을 가로채고 토큰을 검증함
- [x] /api/auth/login 등 permitAll 엔드포인트는 인증 없이 접근 가능
- [x] /api/users/profile 등 인증 필요 엔드포인트는 토큰 없이 접근 시 401 응답
- [x] 유효한 토큰으로 요청 시 SecurityContext에 Authentication 설정됨

---

### [BE-010] 회원가입 API 구현

**Priority**: 🔴 Critical
**Estimated Time**: 6 hours

#### Description

이메일과 비밀번호를 사용한 로컬 회원가입 기능을 구현합니다. 입력값 검증, 중복 확인, 비밀번호 해싱, JWT 토큰 발급까지 전체 프로세스를 처리합니다.

#### Functional Requirements

**1. 회원가입 Request DTO**
RegisterRequest 클래스를 작성합니다:

**필수 필드:**

- email (String, @Email, @NotBlank)
- password (String, @NotBlank, @Size(min=8, max=20))
- name (String, @NotBlank, @Size(min=2, max=50))
- phone (String, Optional, 한국 전화번호 형식 검증)

**Validation 규칙:**

- 이메일: RFC 5322 형식 검증
- 비밀번호: 최소 8자, 최대 20자, 영문+숫자 조합 (정규식 검증)
- 이름: 최소 2자, 최대 50자
- 전화번호: 010-XXXX-XXXX 형식 (하이픈 포함 또는 제외)

**2. 회원가입 Response DTO**
RegisterResponse 클래스를 작성합니다:

**필드:**

- user (UserDTO): id, email, name, membershipTier, createdAt
- accessToken (String)
- refreshToken (String)

**3. AuthController 회원가입 엔드포인트**
`POST /api/auth/register` 엔드포인트를 구현합니다:

**요청 처리 로직:**

1. @Valid를 사용하여 Request DTO 검증 (Bean Validation)
2. 이메일 중복 확인 (UserRepository.existsByEmail())
   - 중복 시 ConflictException 발생 ("EMAIL_ALREADY_EXISTS")
3. 전화번호가 제공된 경우 중복 확인 (UserRepository.existsByPhone())
   - 중복 시 ConflictException 발생 ("PHONE_ALREADY_EXISTS")
4. 비밀번호 해싱 (PasswordEncoder.encode())
5. User Entity 생성 및 저장
   - email, passwordHash, name, phone
   - membershipTier: BASIC (기본값)
   - phoneVerified: false (전화번호 인증 전, Week 22-25에서 SMS 인증 추가)
6. Access Token 생성 (유효기간 1시간)
7. Refresh Token 생성 (유효기간 7일)
8. Refresh Token을 데이터베이스에 저장
9. Response DTO 생성 및 반환 (201 Created)

**4. 비즈니스 로직 분리**
AuthService 클래스를 작성하여 비즈니스 로직을 처리합니다:

- register(RegisterRequest request): RegisterResponse

**5. 추가 검증 로직**
커스텀 Validator를 작성하여 다음을 검증합니다:

- 비밀번호 강도 (영문 대소문자, 숫자 조합)
- 이메일 도메인 화이트리스트 (선택 사항)
- 전화번호 형식 (한국 휴대폰 번호)

**6. Swagger 문서화**
@Operation, @ApiResponse 어노테이션을 사용하여 문서화:

- Summary: "사용자 회원가입"
- Tag: "Auth"
- Request Body: RegisterRequest 스키마
- Responses:
  - 201: 회원가입 성공, RegisterResponse
  - 400: 입력값 검증 실패, Validation 에러 상세
  - 409: 이메일 또는 전화번호 중복

#### API Endpoints

| Method | Endpoint           | Description     | Auth Required |
| ------ | ------------------ | --------------- | ------------- |
| POST   | /api/auth/register | 사용자 회원가입 | No            |

#### Error Handling

- 이메일 중복: 409 CONFLICT, "EMAIL_ALREADY_EXISTS"
- 전화번호 중복: 409 CONFLICT, "PHONE_ALREADY_EXISTS"
- 입력값 검증 실패: 400 BAD_REQUEST, "VALIDATION_ERROR" + details

#### Acceptance Criteria

- [x] 유효한 정보로 회원가입이 성공함
- [x] 회원가입 시 비밀번호가 BCrypt로 해싱되어 저장됨
- [x] 중복된 이메일로 가입 시 409 에러 반환
- [x] 중복된 전화번호로 가입 시 409 에러 반환
- [x] 회원가입 성공 시 Access Token과 Refresh Token이 반환됨
- [x] Bean Validation 실패 시 필드별 에러 상세 정보 반환
- [x] Swagger UI에서 API 테스트 가능

---

### [BE-011] 로그인 API 구현

**Priority**: 🔴 Critical
**Estimated Time**: 4 hours

#### Description

이메일과 비밀번호를 사용한 로그인 기능을 구현합니다. Remember Me 기능을 지원하여 Refresh Token 만료 기간을 조절할 수 있습니다.

#### Functional Requirements

**1. 로그인 Request DTO**
LoginRequest 클래스를 작성합니다:

**필드:**

- email (String, @Email, @NotBlank)
- password (String, @NotBlank)
- rememberMe (Boolean, Optional, default: false)

**2. 로그인 Response DTO**
LoginResponse 클래스를 작성합니다:

**필드:**

- user (UserDTO): id, email, name, membershipTier, profileImageUrl
- accessToken (String)
- refreshToken (String)

**3. AuthController 로그인 엔드포인트**
`POST /api/auth/login` 엔드포인트를 구현합니다:

**요청 처리 로직:**

1. Request DTO 검증
2. email로 User 조회 (UserRepository.findByEmailAndDeletedAtIsNull())
   - 사용자 없음 시 UnauthorizedException 발생 ("INVALID_CREDENTIALS")
   - 탈퇴한 사용자(deletedAt != null)는 로그인 불가
3. 비밀번호 검증 (PasswordEncoder.matches())
   - 불일치 시 UnauthorizedException 발생 ("INVALID_CREDENTIALS")
   - 보안상 "이메일이 틀렸는지 비밀번호가 틀렸는지" 구분하지 않고 동일한 메시지 반환
4. Access Token 생성 (유효기간 1시간)
5. Refresh Token 생성
   - rememberMe = true: 유효기간 30일
   - rememberMe = false: 유효기간 7일
6. Refresh Token을 데이터베이스에 저장
7. Response DTO 생성 및 반환 (200 OK)

**4. 로그인 실패 처리**
보안을 위해 다음 사항을 고려합니다:

- 이메일 존재 여부를 노출하지 않음 (항상 "이메일 또는 비밀번호가 올바르지 않습니다" 메시지)
- 로그인 실패 시도 제한 (선택 사항, Redis 사용)
  - 동일 IP에서 5회 실패 시 5분간 로그인 차단
  - 동일 이메일로 10회 실패 시 계정 잠금 (관리자 해제 필요)

**5. 마지막 로그인 시간 기록**
User Entity에 lastLoginAt 필드 추가 및 업데이트:

- 로그인 성공 시 현재 시간으로 갱신

**6. Swagger 문서화**

- Summary: "사용자 로그인"
- Tag: "Auth"
- Request Body: LoginRequest 스키마
- Responses:
  - 200: 로그인 성공, LoginResponse
  - 401: 인증 실패 (이메일 또는 비밀번호 오류)

#### API Endpoints

| Method | Endpoint        | Description   | Auth Required |
| ------ | --------------- | ------------- | ------------- |
| POST   | /api/auth/login | 사용자 로그인 | No            |

#### Error Handling

- 이메일 또는 비밀번호 오류: 401 UNAUTHORIZED, "INVALID_CREDENTIALS"
- 탈퇴한 계정: 401 UNAUTHORIZED, "ACCOUNT_DELETED"
- 입력값 검증 실패: 400 BAD_REQUEST, "VALIDATION_ERROR"

#### Acceptance Criteria

- [x] 올바른 이메일과 비밀번호로 로그인 성공
- [x] 잘못된 정보로 로그인 시 401 에러 반환
- [x] 탈퇴한 계정으로 로그인 시 401 에러 반환
- [x] Remember Me 체크 시 Refresh Token 만료 기간이 30일로 설정됨
- [x] Remember Me 체크 안 함 시 Refresh Token 만료 기간이 7일로 설정됨
- [x] 로그인 성공 시 lastLoginAt이 업데이트됨
- [x] Access Token과 Refresh Token이 반환됨

---

### [BE-012] 로그아웃 API 구현

**Priority**: 🔴 Critical
**Estimated Time**: 2 hours

#### Description

Refresh Token을 무효화하여 로그아웃 기능을 구현합니다. 단일 디바이스 로그아웃과 모든 디바이스 로그아웃을 지원합니다.

#### Functional Requirements

**1. 로그아웃 Request DTO**
LogoutRequest 클래스를 작성합니다:

**필드:**

- refreshToken (String, Optional)
- logoutAllDevices (Boolean, Optional, default: false)

**2. AuthController 로그아웃 엔드포인트**
`POST /api/auth/logout` 엔드포인트를 구현합니다:

**요청 처리 로직:**

1. 인증 필요 (JWT Access Token)
2. SecurityContext에서 현재 사용자 ID 추출
3. logoutAllDevices = true인 경우:
   - 해당 사용자의 모든 Refresh Token 삭제 (RefreshTokenRepository.deleteByUserId())
   - 모든 디바이스에서 로그아웃 처리
4. logoutAllDevices = false인 경우:
   - Request Body의 refreshToken만 삭제 (RefreshTokenRepository.deleteByToken())
   - 현재 디바이스에서만 로그아웃 처리
5. 성공 메시지 반환 (200 OK)

**3. Access Token 무효화 고려사항**
JWT는 상태를 저장하지 않으므로 Access Token은 만료 전까지 유효합니다. 완전한 로그아웃을 위해 다음 방법 고려:

- Redis에 블랙리스트 저장 (선택 사항)
  - 로그아웃한 Access Token을 Redis에 저장 (TTL: 토큰 만료 시간까지)
  - JwtAuthenticationFilter에서 블랙리스트 확인
- 프론트엔드에서 토큰 삭제 (기본 방법)
  - 로그아웃 시 LocalStorage/SessionStorage에서 토큰 제거
  - 클라이언트가 토큰을 보내지 않으므로 사실상 로그아웃

**4. Swagger 문서화**

- Summary: "사용자 로그아웃"
- Tag: "Auth"
- Security: bearerAuth (JWT 필요)
- Request Body: LogoutRequest 스키마
- Responses:
  - 200: 로그아웃 성공
  - 401: 인증 실패

#### API Endpoints

| Method | Endpoint         | Description     | Auth Required |
| ------ | ---------------- | --------------- | ------------- |
| POST   | /api/auth/logout | 사용자 로그아웃 | Yes           |

#### Error Handling

- 인증 실패: 401 UNAUTHORIZED, "UNAUTHORIZED"

#### Acceptance Criteria

- [x] 로그아웃 시 Refresh Token이 데이터베이스에서 삭제됨
- [x] logoutAllDevices = true 시 모든 Refresh Token 삭제됨
- [x] 로그아웃 후 해당 Refresh Token으로 토큰 갱신 불가
- [x] 인증된 사용자만 로그아웃 가능

---

### [BE-013] Token Refresh API 구현

**Priority**: 🔴 Critical
**Estimated Time**: 3 hours

#### Description

Refresh Token을 사용하여 새로운 Access Token을 발급하는 기능을 구현합니다. Access Token이 만료되었을 때 사용자가 다시 로그인하지 않아도 되도록 합니다.

#### Functional Requirements

**1. Token Refresh Request DTO**
RefreshTokenRequest 클래스를 작성합니다:

**필드:**

- refreshToken (String, @NotBlank)

**2. Token Refresh Response DTO**
RefreshTokenResponse 클래스를 작성합니다:

**필드:**

- accessToken (String)
- refreshToken (String, Optional - Refresh Token도 갱신하는 경우)

**3. AuthController Token Refresh 엔드포인트**
`POST /api/auth/refresh` 엔드포인트를 구현합니다:

**요청 처리 로직:**

1. Request Body에서 refreshToken 추출
2. JWT 검증 (JwtTokenProvider.verifyRefreshToken())
   - 서명 검증, 만료 확인
   - 실패 시 UnauthorizedException 발생 ("INVALID_TOKEN")
3. 토큰에서 userId 추출
4. 데이터베이스에서 Refresh Token 조회 (RefreshTokenRepository.findByToken())
   - 없으면 UnauthorizedException 발생 ("INVALID_TOKEN")
   - DB에 저장된 Refresh Token과 일치하지 않으면 무효화 (탈취 가능성)
5. expiresAt 확인
   - 만료된 경우 토큰 삭제 후 UnauthorizedException 발생 ("TOKEN_EXPIRED")
6. User 조회 (UserRepository.findById())
   - 사용자 없음 또는 탈퇴한 경우 UnauthorizedException 발생
7. 새 Access Token 생성 (유효기간 1시간)
8. (선택 사항) Refresh Token도 갱신
   - Refresh Token Rotation 전략: 보안 강화를 위해 Refresh Token도 함께 갱신
   - 기존 Refresh Token 삭제, 새 Refresh Token 생성 및 저장
9. Response DTO 생성 및 반환 (200 OK)

**4. Refresh Token 정리 스케줄러 (선택 사항)**
만료된 Refresh Token을 정기적으로 삭제하는 스케줄러를 작성합니다:

- @Scheduled(cron = "0 0 3 \* \* ?") - 매일 새벽 3시 실행
- expiresAt < 현재 시간인 토큰 삭제
- 데이터베이스 크기 관리

**5. Swagger 문서화**

- Summary: "Access Token 갱신"
- Tag: "Auth"
- Request Body: RefreshTokenRequest 스키마
- Responses:
  - 200: 토큰 갱신 성공, RefreshTokenResponse
  - 401: Refresh Token 무효 또는 만료

#### API Endpoints

| Method | Endpoint          | Description       | Auth Required           |
| ------ | ----------------- | ----------------- | ----------------------- |
| POST   | /api/auth/refresh | Access Token 갱신 | No (Refresh Token 사용) |

#### Error Handling

- Refresh Token 없음: 401 UNAUTHORIZED, "INVALID_TOKEN"
- Refresh Token 만료: 401 UNAUTHORIZED, "TOKEN_EXPIRED"
- Refresh Token 서명 무효: 401 UNAUTHORIZED, "INVALID_TOKEN"
- 사용자 없음: 401 UNAUTHORIZED, "USER_NOT_FOUND"

#### Acceptance Criteria

- [x] 유효한 Refresh Token으로 새 Access Token 발급 성공
- [x] 만료된 Refresh Token은 거부되고 401 에러 반환
- [x] 유효하지 않은 Refresh Token은 거부되고 401 에러 반환
- [x] 데이터베이스에 없는 Refresh Token은 거부됨
- [x] 탈퇴한 사용자의 Refresh Token은 거부됨
- [x] (선택) Refresh Token Rotation이 동작하면 새 Refresh Token도 반환됨

---

### [BE-014] 비밀번호 변경 API 구현 (로그인 상태)

**Priority**: 🟡 High
**Estimated Time**: 4 hours

#### Description

로그인한 사용자가 현재 비밀번호를 알고 있을 때 새 비밀번호로 변경할 수 있는 기능을 구현합니다. 비밀번호 찾기(이메일 인증)는 Week 22-25에서 구현합니다.

#### Functional Requirements

**1. 비밀번호 변경 Request DTO**
ChangePasswordRequest 클래스를 작성합니다:

**필드:**

- currentPassword (String, @NotBlank)
- newPassword (String, @NotBlank, @Size(min=8, max=20))
- confirmPassword (String, @NotBlank)

**Validation:**

- newPassword와 confirmPassword 일치 확인 (커스텀 Validator)
- newPassword 강도 검증 (영문+숫자 조합)

**2. UserController 비밀번호 변경 엔드포인트**
`PUT /api/users/password` 엔드포인트를 구현합니다:

**요청 처리 로직:**

1. 인증 필요 (JWT Access Token)
2. SecurityContext에서 현재 사용자 ID 추출
3. User 조회
4. 현재 비밀번호 검증 (PasswordEncoder.matches())
   - 불일치 시 UnauthorizedException 발생 ("INVALID_PASSWORD")
5. newPassword와 confirmPassword 일치 확인
   - 불일치 시 ValidationException 발생
6. 새 비밀번호 해싱 (PasswordEncoder.encode())
7. User Entity의 passwordHash 업데이트
8. (선택 사항) 보안 강화: 모든 Refresh Token 무효화
   - 비밀번호 변경 시 모든 디바이스에서 재로그인 요구
9. 성공 메시지 반환 (200 OK)

**3. UserService 비즈니스 로직**
changePassword(Long userId, ChangePasswordRequest request) 메서드 작성

**4. Swagger 문서화**

- Summary: "비밀번호 변경"
- Tag: "Users"
- Security: bearerAuth
- Request Body: ChangePasswordRequest 스키마
- Responses:
  - 200: 비밀번호 변경 성공
  - 401: 현재 비밀번호 오류 또는 인증 실패
  - 400: 입력값 검증 실패

#### API Endpoints

| Method | Endpoint            | Description   | Auth Required |
| ------ | ------------------- | ------------- | ------------- |
| PUT    | /api/users/password | 비밀번호 변경 | Yes           |

#### Error Handling

- 현재 비밀번호 오류: 401 UNAUTHORIZED, "INVALID_PASSWORD"
- newPassword와 confirmPassword 불일치: 400 BAD_REQUEST, "PASSWORDS_DO_NOT_MATCH"
- 비밀번호 강도 미달: 400 BAD_REQUEST, "WEAK_PASSWORD"

#### Acceptance Criteria

- [x] 올바른 현재 비밀번호로 비밀번호 변경 성공
- [x] 잘못된 현재 비밀번호로 변경 시도 시 401 에러 반환
- [x] newPassword와 confirmPassword 불일치 시 400 에러 반환
- [x] 새 비밀번호가 BCrypt로 해싱되어 저장됨
- [x] (선택) 비밀번호 변경 시 모든 Refresh Token 무효화됨

**Note**: 비밀번호 찾기(이메일 인증을 통한 재설정)는 Week 22-25에서 AWS SES와 함께 구현됩니다.

---

### [BE-015] 사용자 프로필 조회 API 구현

**Priority**: 🔴 Critical
**Estimated Time**: 2 hours

#### Description

로그인한 사용자의 프로필 정보를 조회하는 API를 구현합니다. 민감한 정보는 제외하고 필요한 정보만 반환합니다.

#### Functional Requirements

**1. 사용자 프로필 Response DTO**
UserProfileResponse 클래스를 작성합니다:

**필드:**

- id (Long)
- email (String)
- name (String)
- phone (String, nullable)
- phoneVerified (Boolean)
- membershipTier (String - BASIC/VIP/WHOLESALE)
- profileImageUrl (String, nullable)
- createdAt (LocalDateTime)
- lastLoginAt (LocalDateTime, nullable)

**제외할 필드:**

- passwordHash (절대 노출 금지)
- deletedAt (내부 사용)

**2. UserController 프로필 조회 엔드포인트**
`GET /api/users/profile` 엔드포인트를 구현합니다:

**요청 처리 로직:**

1. 인증 필요 (JWT Access Token)
2. SecurityContext에서 현재 사용자 ID 추출
3. User 조회 (UserRepository.findById())
4. UserProfileResponse DTO로 변환
5. Response 반환 (200 OK)

**3. DTO 변환 로직**
UserMapper 또는 ModelMapper를 사용하여 Entity → DTO 변환:

- Entity의 모든 필드를 DTO로 복사하되 passwordHash 제외
- 자동 매핑 도구 사용 권장 (MapStruct, ModelMapper)

**4. Swagger 문서화**

- Summary: "사용자 프로필 조회"
- Tag: "Users"
- Security: bearerAuth
- Responses:
  - 200: 프로필 조회 성공, UserProfileResponse
  - 401: 인증 실패

#### API Endpoints

| Method | Endpoint           | Description        | Auth Required |
| ------ | ------------------ | ------------------ | ------------- |
| GET    | /api/users/profile | 사용자 프로필 조회 | Yes           |

#### Error Handling

- 인증 실패: 401 UNAUTHORIZED, "UNAUTHORIZED"
- 사용자 없음: 404 NOT_FOUND, "USER_NOT_FOUND" (정상적으로는 발생하지 않음)

#### Acceptance Criteria

- [x] 인증된 사용자의 프로필 정보가 반환됨
- [x] 비밀번호 해시가 응답에 포함되지 않음
- [x] 모든 필요한 사용자 정보가 포함됨 (이메일, 이름, 멤버십 등급 등)
- [x] 인증 없이 요청 시 401 에러 반환

---

### [BE-016] 사용자 프로필 수정 API 구현

**Priority**: 🔴 Critical
**Estimated Time**: 4 hours

#### Description

사용자가 자신의 프로필 정보(이름, 전화번호, 프로필 이미지)를 수정할 수 있는 API를 구현합니다. 이메일은 보안상 수정 불가로 처리합니다.

#### Functional Requirements

**1. 프로필 수정 Request DTO**
UpdateProfileRequest 클래스를 작성합니다:

**필드:**

- name (String, Optional, @Size(min=2, max=50))
- phone (String, Optional, 한국 전화번호 형식)
- profileImageUrl (String, Optional, URL 형식)

**Validation:**

- 모든 필드 Optional (제공된 필드만 업데이트)
- name: 2-50자
- phone: 010-XXXX-XXXX 형식
- profileImageUrl: 유효한 URL (http:// 또는 https://)

**2. UserController 프로필 수정 엔드포인트**
`PUT /api/users/profile` 엔드포인트를 구현합니다:

**요청 처리 로직:**

1. 인증 필요 (JWT Access Token)
2. SecurityContext에서 현재 사용자 ID 추출
3. Request DTO 검증
4. 전화번호 변경 시 중복 확인
   - 다른 사용자가 이미 사용 중인 번호인지 확인
   - 중복 시 ConflictException 발생 ("PHONE_ALREADY_EXISTS")
5. User Entity 조회
6. 제공된 필드만 업데이트 (null이 아닌 필드만)
   - name이 제공되면 name 업데이트
   - phone이 제공되면 phone 업데이트, phoneVerified = false로 설정
   - profileImageUrl이 제공되면 profileImageUrl 업데이트
7. User Entity 저장
8. 업데이트된 User를 UserProfileResponse로 변환하여 반환 (200 OK)

**3. 전화번호 변경 시 재인증 처리**

- 전화번호가 변경되면 phoneVerified를 false로 설정
- 사용자는 새 전화번호로 SMS 인증을 다시 받아야 함 (Week 22-25에서 구현)

**4. 이메일 변경 제한**

- 이메일은 계정 식별자이므로 수정 불가
- 이메일 변경이 필요한 경우 별도의 보안 프로세스 필요 (현재는 미구현)

**5. UserService 비즈니스 로직**
updateProfile(Long userId, UpdateProfileRequest request): UserProfileResponse

**6. Swagger 문서화**

- Summary: "사용자 프로필 수정"
- Tag: "Users"
- Security: bearerAuth
- Request Body: UpdateProfileRequest 스키마
- Responses:
  - 200: 프로필 수정 성공, UserProfileResponse
  - 400: 입력값 검증 실패
  - 409: 전화번호 중복
  - 401: 인증 실패

#### API Endpoints

| Method | Endpoint           | Description        | Auth Required |
| ------ | ------------------ | ------------------ | ------------- |
| PUT    | /api/users/profile | 사용자 프로필 수정 | Yes           |

#### Error Handling

- 전화번호 중복: 409 CONFLICT, "PHONE_ALREADY_EXISTS"
- 입력값 검증 실패: 400 BAD_REQUEST, "VALIDATION_ERROR"
- 인증 실패: 401 UNAUTHORIZED, "UNAUTHORIZED"

#### Acceptance Criteria

- [x] 사용자가 이름, 전화번호, 프로필 이미지를 수정할 수 있음
- [x] 수정된 정보가 데이터베이스에 저장됨
- [x] 전화번호 변경 시 phoneVerified가 false로 설정됨
- [x] 중복된 전화번호로 변경 시도 시 409 에러 반환
- [x] 일부 필드만 제공해도 해당 필드만 업데이트됨
- [x] 수정된 프로필 정보가 응답으로 반환됨

---

### [BE-017] 배송지 관리 API 구현

**Priority**: 🔴 Critical
**Estimated Time**: 6 hours

#### Description

사용자가 여러 개의 배송지를 등록하고 관리할 수 있는 API를 구현합니다. 기본 배송지 설정, 배송지 목록 조회, 추가, 수정, 삭제 기능을 제공합니다.

#### Functional Requirements

**1. 배송지 Request/Response DTO**

**AddressRequest DTO:**

- recipientName (String, @NotBlank, @Size(max=100))
- phone (String, @NotBlank, 한국 전화번호 형식)
- postalCode (String, @NotBlank, @Size(5~6))
- address (String, @NotBlank, @Size(max=255))
- detailAddress (String, Optional, @Size(max=255))
- isDefault (Boolean, Optional, default: false)

**AddressResponse DTO:**

- id (Long)
- recipientName (String)
- phone (String)
- postalCode (String)
- address (String)
- detailAddress (String, nullable)
- isDefault (Boolean)
- createdAt (LocalDateTime)

**2. AddressController 엔드포인트 구현**

**배송지 목록 조회: GET /api/users/addresses**

- 인증 필요
- 현재 사용자의 모든 배송지 조회 (삭제되지 않은 것만)
- 정렬: isDefault DESC, createdAt DESC (기본 배송지가 맨 위)
- 응답: List<AddressResponse>

**배송지 추가: POST /api/users/addresses**

- 인증 필요
- Request Body: AddressRequest
- 비즈니스 로직:
  1. 사용자의 배송지 개수 확인 (최대 10개 제한)
  2. isDefault = true인 경우, 기존 기본 배송지를 false로 변경
  3. 첫 번째 배송지인 경우 자동으로 isDefault = true 설정
  4. Address Entity 생성 및 저장
- 응답: AddressResponse (201 Created)

**배송지 수정: PUT /api/users/addresses/{addressId}**

- 인증 필요
- Path Variable: addressId
- Request Body: AddressRequest
- 비즈니스 로직:
  1. addressId로 배송지 조회
  2. 해당 배송지가 현재 사용자의 것인지 확인 (userId 일치)
     - 불일치 시 ForbiddenException 발생
  3. isDefault = true로 변경 시, 기존 기본 배송지를 false로 변경
  4. Address Entity 업데이트
- 응답: AddressResponse (200 OK)

**배송지 삭제: DELETE /api/users/addresses/{addressId}**

- 인증 필요
- Path Variable: addressId
- 비즈니스 로직:
  1. addressId로 배송지 조회
  2. 해당 배송지가 현재 사용자의 것인지 확인
  3. 기본 배송지인 경우 삭제 불가 (다른 배송지를 기본으로 설정 후 삭제 가능)
     - ValidationException 발생 ("CANNOT_DELETE_DEFAULT_ADDRESS")
  4. Address Entity 삭제 (Hard Delete 또는 Soft Delete)
- 응답: 성공 메시지 (200 OK)

**기본 배송지 설정: PUT /api/users/addresses/{addressId}/default**

- 인증 필요
- Path Variable: addressId
- 비즈니스 로직:
  1. addressId로 배송지 조회
  2. 해당 배송지가 현재 사용자의 것인지 확인
  3. 기존 기본 배송지를 false로 변경
  4. 해당 배송지를 isDefault = true로 설정
- 응답: AddressResponse (200 OK)

**3. AddressService 비즈니스 로직**
다음 메서드를 구현합니다:

- getAddressesByUserId(Long userId): List<AddressResponse>
- addAddress(Long userId, AddressRequest request): AddressResponse
- updateAddress(Long userId, Long addressId, AddressRequest request): AddressResponse
- deleteAddress(Long userId, Long addressId): void
- setDefaultAddress(Long userId, Long addressId): AddressResponse

**4. 배송지 개수 제한**

- 한 사용자당 최대 10개의 배송지 등록 가능
- 초과 시 ValidationException 발생 ("MAX_ADDRESSES_REACHED")

**5. 기본 배송지 관리**

- 한 사용자는 반드시 1개의 기본 배송지를 가져야 함
- 첫 번째 배송지는 자동으로 기본 배송지로 설정
- 기본 배송지를 다른 배송지로 변경 시 기존 기본 배송지는 자동으로 일반 배송지로 변경

**6. Swagger 문서화**
각 엔드포인트에 대해 @Operation, @ApiResponse 어노테이션 추가

#### API Endpoints

| Method | Endpoint                                 | Description      | Auth Required |
| ------ | ---------------------------------------- | ---------------- | ------------- |
| GET    | /api/users/addresses                     | 배송지 목록 조회 | Yes           |
| POST   | /api/users/addresses                     | 배송지 추가      | Yes           |
| PUT    | /api/users/addresses/{addressId}         | 배송지 수정      | Yes           |
| DELETE | /api/users/addresses/{addressId}         | 배송지 삭제      | Yes           |
| PUT    | /api/users/addresses/{addressId}/default | 기본 배송지 설정 | Yes           |

#### Error Handling

- 배송지 개수 초과: 400 BAD_REQUEST, "MAX_ADDRESSES_REACHED"
- 기본 배송지 삭제 시도: 400 BAD_REQUEST, "CANNOT_DELETE_DEFAULT_ADDRESS"
- 다른 사용자의 배송지 접근: 403 FORBIDDEN, "FORBIDDEN"
- 배송지 없음: 404 NOT_FOUND, "ADDRESS_NOT_FOUND"
- 입력값 검증 실패: 400 BAD_REQUEST, "VALIDATION_ERROR"

#### Acceptance Criteria

- [x] 사용자가 배송지를 추가, 조회, 수정, 삭제할 수 있음
- [x] 한 사용자당 최대 10개 배송지 등록 제한이 적용됨
- [x] 첫 번째 배송지는 자동으로 기본 배송지로 설정됨
- [x] 기본 배송지 변경 시 기존 기본 배송지는 일반 배송지로 변경됨
- [x] 기본 배송지는 삭제할 수 없음
- [x] 다른 사용자의 배송지에 접근 시 403 에러 반환
- [x] 배송지 목록은 기본 배송지가 맨 위에 표시됨

---

### [BE-018] 회원 탈퇴 API 구현

**Priority**: 🟢 Medium
**Estimated Time**: 3 hours

#### Description

사용자가 계정을 삭제할 수 있는 기능을 구현합니다. Soft Delete 방식을 사용하여 데이터를 보존하고, 향후 복구 또는 데이터 분석에 활용할 수 있도록 합니다.

#### Functional Requirements

**1. 회원 탈퇴 Request DTO**
DeleteAccountRequest 클래스를 작성합니다:

**필드:**

- password (String, @NotBlank) - 본인 확인용
- reason (String, Optional, @Size(max=500)) - 탈퇴 사유

**2. UserController 회원 탈퇴 엔드포인트**
`DELETE /api/users/account` 엔드포인트를 구현합니다:

**요청 처리 로직:**

1. 인증 필요 (JWT Access Token)
2. SecurityContext에서 현재 사용자 ID 추출
3. Request Body에서 password 및 reason 추출
4. User 조회
5. 비밀번호 검증 (PasswordEncoder.matches())
   - 불일치 시 UnauthorizedException 발생 ("INVALID_PASSWORD")
6. Soft Delete 처리
   - deletedAt 필드를 현재 시간으로 설정
   - email을 "deleted*{userId}*{timestamp}@deleted.com" 형식으로 변경 (재가입 허용)
7. 모든 Refresh Token 무효화 (RefreshTokenRepository.deleteByUserId())
8. 탈퇴 사유 로깅 (선택 사항)
   - 탈퇴 사유를 별도 테이블에 저장하거나 로그에 기록
9. 성공 메시지 반환 (200 OK)

**3. Soft Delete 구현**
User Entity의 deletedAt 필드를 활용:

- deletedAt이 null이 아니면 탈퇴한 계정
- 로그인, 프로필 조회 등 모든 API에서 deletedAt != null인 사용자 제외
- JPA Query에서 `@Where(clause = "deleted_at IS NULL")` 사용 또는 Repository 메서드에서 명시적 확인

**4. 재가입 허용을 위한 이메일 처리**
탈퇴 후 동일한 이메일로 재가입할 수 있도록:

- 탈퇴 시 email을 "deleted*{userId}*{timestamp}@deleted.com"으로 변경
- UNIQUE 제약 조건 유지
- 탈퇴한 사용자의 실제 이메일은 별도 로그 또는 백업에 저장 (선택 사항)

**5. 관련 데이터 처리**
탈퇴 시 다음 데이터를 어떻게 처리할지 정의:

- Address: CASCADE DELETE (배송지 함께 삭제)
- CartItem: CASCADE DELETE (장바구니 함께 삭제)
- Order: 유지 (주문 이력은 보존, 법적 요구사항)
- MileageTransaction, DepositTransaction: 유지 (거래 이력 보존)
- RefreshToken: 즉시 삭제 (로그아웃)

**6. Swagger 문서화**

- Summary: "회원 탈퇴"
- Tag: "Users"
- Security: bearerAuth
- Request Body: DeleteAccountRequest 스키마
- Responses:
  - 200: 회원 탈퇴 성공
  - 401: 비밀번호 오류 또는 인증 실패

#### API Endpoints

| Method | Endpoint           | Description | Auth Required |
| ------ | ------------------ | ----------- | ------------- |
| DELETE | /api/users/account | 회원 탈퇴   | Yes           |

#### Error Handling

- 비밀번호 오류: 401 UNAUTHORIZED, "INVALID_PASSWORD"
- 인증 실패: 401 UNAUTHORIZED, "UNAUTHORIZED"

#### Acceptance Criteria

- [x] 올바른 비밀번호로 회원 탈퇴 성공
- [x] 잘못된 비밀번호로 탈퇴 시도 시 401 에러 반환
- [x] 탈퇴 시 deletedAt이 현재 시간으로 설정됨
- [x] 탈퇴 시 email이 변경되어 재가입 가능
- [x] 모든 Refresh Token이 삭제됨
- [x] 탈퇴 사유가 제공되면 로그에 기록됨
- [x] 탈퇴한 계정으로 로그인 시도 시 401 에러 반환
- [x] 탈퇴 후 동일한 이메일로 재가입 가능

---

## 📊 Week 3-4 Summary

### Deliverables

- ✅ Spring Security 6.x 설정 완료
- ✅ JWT 기반 인증 시스템 (Access Token + Refresh Token)
- ✅ 회원가입, 로그인, 로그아웃 API
- ✅ Token Refresh API
- ✅ 비밀번호 변경 API (로그인 상태)
- ✅ 사용자 프로필 조회 및 수정 API
- ✅ 배송지 관리 CRUD API
- ✅ 회원 탈퇴 API (Soft Delete)

### Key Endpoints (Week 3-4)

| Method | Endpoint                                 | Description       | Auth Required      |
| ------ | ---------------------------------------- | ----------------- | ------------------ |
| POST   | /api/auth/register                       | 회원가입          | No                 |
| POST   | /api/auth/login                          | 로그인            | No                 |
| POST   | /api/auth/logout                         | 로그아웃          | Yes                |
| POST   | /api/auth/refresh                        | Access Token 갱신 | No (Refresh Token) |
| PUT    | /api/users/password                      | 비밀번호 변경     | Yes                |
| GET    | /api/users/profile                       | 프로필 조회       | Yes                |
| PUT    | /api/users/profile                       | 프로필 수정       | Yes                |
| GET    | /api/users/addresses                     | 배송지 목록 조회  | Yes                |
| POST   | /api/users/addresses                     | 배송지 추가       | Yes                |
| PUT    | /api/users/addresses/{addressId}         | 배송지 수정       | Yes                |
| DELETE | /api/users/addresses/{addressId}         | 배송지 삭제       | Yes                |
| PUT    | /api/users/addresses/{addressId}/default | 기본 배송지 설정  | Yes                |
| DELETE | /api/users/account                       | 회원 탈퇴         | Yes                |

### Security Features

- JWT Access Token: 1시간 유효
- JWT Refresh Token: 7일 (Remember Me: 30일)
- BCrypt 비밀번호 해싱 (strength: 10)
- Refresh Token 데이터베이스 관리
- CORS 설정 (프론트엔드 도메인 허용)
- CSRF 비활성화 (REST API)
- Stateless Session Management

### Database Changes

- refresh_tokens 테이블 추가
- User Entity에 lastLoginAt 필드 추가 (선택 사항)

### Frontend Integration Ready

Week 4부터 프론트엔드 팀이 다음 기능을 연동할 수 있습니다:

- 회원가입 폼
- 로그인 폼 (Remember Me 옵션 포함)
- 프로필 페이지 (조회/수정)
- 배송지 관리 페이지
- 비밀번호 변경 폼
- 회원 탈퇴 폼
- JWT 토큰 자동 갱신 (Axios Interceptor 등)

### Postponed to Week 22-25 (External APIs)

다음 기능은 외부 API 연동이 필요하므로 Week 22-25로 연기되었습니다:

- ❌ 네이버 OAuth 2.0 로그인
- ❌ 카카오 OAuth 2.0 로그인
- ❌ SMS 전화번호 인증
- ❌ 이메일 인증을 통한 비밀번호 찾기/재설정

### Next Steps (Week 5-8)

- 상품 및 카테고리 CRUD API
- 상품 검색 및 필터링 (카테고리, 가격, 등급)
- 상품 이미지 업로드 (AWS S3)
- 베스트 상품, 신상품 조회 API
- 상품 조회수 증가

---

**Documentation Style**: 이 문서는 명시적인 코드 예시 없이 기능 요구사항을 텍스트로 상세히 설명하는 방식으로 작성되었습니다. 개발자는 이 요구사항을 읽고 Java/Spring Boot 기반으로 직접 구현할 수 있습니다.

**Local Development Focus**: Week 3-4는 외부 API 연동 없이 로컬 개발에 집중합니다. 모든 인증 기능은 JWT로 처리하며, 소셜 로그인, SMS 인증, 이메일 인증은 Week 22-25에서 구현됩니다.
